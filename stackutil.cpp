#define _FILE_OFFSET_BITS  64  //20140919

#ifndef __STACKUTIL_CPP__
#define __STACKUTIL_CPP__



// 64-bit and 32-bit checking
// Windows
#if _WIN32 || _WIN64
#if _WIN64
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

// GCC
#if __GNUC__
#if __x86_64__ || __ppc64__
#define ENVIRONMENT64
#else
#define ENVIRONMENT32
#endif
#endif

//#include "../elementmexheader.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

#include "stackutil.h"
#include "basic_memory.cpp" //change basic_memory.h to basic_memory.cpp, 080302

/*
extern "C" {
*/
#include "mg_image_lib.h"
/*
};
*/

//#define _ALLOW_WORKMODE_MENU_    //indeed this seems not really working well, as many plugins need to add additional src files, noted PHC, 20130127

#ifdef _ALLOW_WORKMODE_MENU_
#include "../neuron_annotator/utility/ImageLoaderBasic.h"
#endif


#define b_VERBOSE_PRINT 1
#define ZZBIG 320000 //previous I define it as 1500, so that to limit the size of an image is at most 1.5G //change 2010-05-21 // hang 2011-08-25 6000->10000

#ifdef _MSC_VER       //2010-05-21, by PHC
#include <sys/stat.h>
#include <io.h>
#endif

#define DEFINE_NBYTE2G \
  V3DLONG nBytes2G = ((V3DLONG)(1024)*(V3DLONG)(1024)*(V3DLONG)(1024)-1)*(V3DLONG)(2);


//int b_VERBOSE_PRINT=1;
/* a simple surfix function.*/

const char * getSuffix(const char *filename)
{
	if (!filename)
		return 0;

	V3DLONG i=0,k=-1;
	while (filename[i]!='\0')
	{
		if (filename[i]=='.')
			k=i;
		i++;
	}

	if (k==-1 || k==i)
		return 0;

	return (filename+k+1);
}


/* The following is the core function for image stack reading of 2 byte raw*/

int loadRaw2Stack_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	
	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = (V3DLONG)(unitSize)*(V3DLONG)(totalUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	V3DLONG remainingBytes = totalBytes;

    DEFINE_NBYTE2G
	
    V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;
		V3DLONG curReadUnits = curReadBytes/unitSize;
		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
		if (nread!=curReadUnits)
		{
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;
        printf("Finish reading %5.4f%%\r", (1-double(remainingBytes)/(double(totalBytes)))*100.0); fflush(stdout);
        cntBuf++;
	}
	
	
	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


int loadRaw2Stack_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //overload for convenience to read only 1 channel
{
	/* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*2+1) /* datatype has 2 bytes, and sz has 4*2 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	fread(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
	{
		for (i=0;i<4;i++)
			swap2bytes((void *)(mysz+i));
	}

	//081204
	if (chan_id_to_load<0 || chan_id_to_load>=mysz[3])
	{
                printf("The specified chan_id_to_load [=%d] is out of the valid of the image data [=%d] \n", chan_id_to_load, mysz[3]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, channelUnit=1;
	for (i=0;i<3;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		channelUnit *= sz[i];
	}
	sz[3] = 1; //this must be true in case only one channel is read
	totalUnit = channelUnit*mysz[3];

	if (totalUnit*unitSize+4*2+2+1+lenkey != fileSize)
	{
		printf("The input file has a size [%ld bytes] to what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*2+2+lenkey);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = (V3DLONG)(unitSize)*(V3DLONG)(channelUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack_2byte().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	if (chan_id_to_load>0) //other no need to call the function
		fseek(fid, channelUnit*chan_id_to_load*unitSize, SEEK_CUR);

	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G
	
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;
		V3DLONG curReadUnits = curReadBytes/unitSize;
		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
		if (nread!=curReadUnits)
		{
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;
        printf("Finish reading %5.4f%%\r", (1-double(remainingBytes)/(double(totalBytes))*100.0)); fflush(stdout);
        cntBuf++;
	}

	
	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


/* The following is the core function for image stack writing of 2-byte raw*/

int saveStack2Raw_2byte(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	short int mysz[4];
	//if (b_swap)  {
	for (i=0;i<4;i++) mysz[i] = (short int) sz[i];
	//swap2bytes((void *)(mysz+i));
	//}
	nwrite = fwrite(mysz, 2, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
if (nwrite!=4)
{
    printf("Writing file error.\n");
    berror = 1;
    return berror;
}

V3DLONG totalUnit = 1;
for (i=0;i<4;i++)
{
    totalUnit *= sz[i];
}

nwrite = fwrite(img, unitSize, totalUnit, fid);
if (nwrite!=totalUnit)
{
    printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
    berror = 1;
    return berror;
}

/* swap the data bytes if necessary */
/*
 if (b_swap==1)
 {
	 if (unitSize==2)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap2bytes((void *)(img+i*unitSize));
		 }
	 }
	 else if (unitSize==4)
	 {
		 for (i=0;i<totalUnit; i++)
		 {
			 swap4bytes((void *)(img+i*unitSize));
		 }
	 }
 }
 */


/* clean and return */

fclose(fid);

return berror;
}

/* The following is the core function for image stack reading */

int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
		//mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
          sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	/*
#ifdef _MSC_VER
	struct stat stbuf;
	int myfd;
	myfd = open(filename, O_RDONLY);
	if (myfd<0) 
	{
		printf("Fail to use open() for this file. \n");
		berror=1;
		return berror;
	}
	FILE * fid = fdopen(myfd, "rb");
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}
	if (fstat(myfd, &stbuf) == -1)
	{
		printf("Fail to get the file status. \n");
		berror=1;
		return berror;
	}
	V3DLONG fileSize = stbuf.st_size;
#else
*/
	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);
/*
#endif
*/
	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	V3DLONG lenkey = strlen(formatkey);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if (fileSize<lenkey+2+4*4+1) // datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. 
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		printf("The fseek-ftell produces a file size = %ld.", fileSize);
		berror = 1;
		return berror;
	}
#endif

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	printf("The data endian code is [%c]\n", endianCodeData);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine;
	endianCodeMachine = checkMachineEndian();
	printf("The machine endian code is [%c]\n", endianCodeMachine);
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
				berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; // temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. 

	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); // because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. 
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; // reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. 
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

		//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);

#ifndef _MSC_VER //added by PHC, 2010-05-21
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
#endif

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = (V3DLONG)(unitSize)*(V3DLONG)(totalUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G

    printf("\n");
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;

//        V3DLONG curReadUnits = curReadBytes/unitSize; //no need to use, 2014-9-21

        //nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid); //this seems to be the bug in the unable to read >2G float data, 20140921, by PHC
        nread = fread(img+cntBuf*nBytes2G, 1, curReadBytes, fid); // a fix of the bug for ">2G float data " reading,. seems there is a bug in fread()!!!

         printf("Just read %ld units, each unit has the size = %ld\n", nread/unitSize, unitSize);   fflush(stdout);

//		if (nread!=curReadUnits)
        if (nread!=curReadBytes) //20140921. by PHC
        {
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;

//        printf("Finish reading %5.4f%% \r", (1-double(remainingBytes)/(double(totalBytes)))*100.0); fflush(stdout);
        if (remainingBytes>0)
        {
            printf("Finish reading %5.4f%% \n", (1-double(remainingBytes)/(double(totalBytes)))*100.0);
            fflush(stdout);
        }
        else
        {
            printf("Finish reading 100%% \n");
            fflush(stdout);
        }

		cntBuf++;
	}

	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}
	else
	{
      printf("No swapping of data. \n");
	}


	// clean and return 

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

    if (b_VERBOSE_PRINT && 0)
    {
        //a debug check of the min max value
        switch (dcode)
        {
        case 1:
        {
            unsigned char *img1 = img;
            float minvv=img1[0], maxvv=img1[0];
            for (V3DLONG myii=1; myii<totalUnit;myii++)
            {
                if (minvv>img1[myii]) minvv=img1[myii];
                else if (maxvv<img1[myii]) maxvv=img1[myii];
            }
            printf("*** for loadRaw2Stack() all readin units: [minvv=%5.3f maxvv=%5.3f]\n", minvv, maxvv);
        }
            break;

        case 2:
        {
            unsigned short int *img1 = (unsigned short int *)img;
            float minvv=img1[0], maxvv=img1[0];
            for (V3DLONG myii=1; myii<totalUnit;myii++)
            {
                if (minvv>img1[myii]) minvv=img1[myii];
                else if (maxvv<img1[myii]) maxvv=img1[myii];
            }
            printf("*** for loadRaw2Stack() all readin units: [minvv=%5.3f maxvv=%5.3f]\n", minvv, maxvv);
        }
            break;

        case 4:
        {
            float *img1 = (float *)img;
            float minvv=img1[0], maxvv=img1[0];
            for (V3DLONG myii=1; myii<totalUnit;myii++)
            {
                if (minvv>img1[myii]) minvv=img1[myii];
                else if (maxvv<img1[myii]) maxvv=img1[myii];
            }
            printf("*** for loadRaw2Stack() all readin units: [minvv=%5.3f maxvv=%5.3f]\n", minvv, maxvv);
        }
            break;

        default:
            printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
            if (keyread) {delete []keyread; keyread=0;}
            berror = 1;
            return berror;
        }
    }

	return berror;
}

int loadRaw2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int chan_id_to_load) //this is the function of 4-byte raw format.
{
    /* This function reads 2-4D image stack from raw data generated by the program "saveStack2Raw.m". */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*4+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[4];//060806
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<4;i++)
		{
			//swap2bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	//081204
	if (chan_id_to_load<0 || chan_id_to_load>=mysz[3])
	{
                printf("The specified chan_id_to_load [=%d] is out of the valid of the image data [=%d] \n", chan_id_to_load, mysz[3]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, channelUnit=1;
	for (i=0;i<3;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		channelUnit *= sz[i];
	}
	sz[3] = 1; //this must be true in case only one channel is read
	totalUnit = channelUnit*mysz[3];

	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	if ((totalUnit*unitSize+4*4+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	V3DLONG totalBytes = (V3DLONG)(unitSize)*(V3DLONG)(channelUnit);
	try 
	{
		img = new unsigned char [totalBytes];
	}
	catch (...)
	{
		fprintf(stderr, "Fail to allocate memory in loadRaw2Stack_2byte().\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}
	
	if (chan_id_to_load>0) //other no need to call the function
		fseek(fid, channelUnit*chan_id_to_load*unitSize, SEEK_CUR);
	
	V3DLONG remainingBytes = totalBytes;
    
    DEFINE_NBYTE2G
	
	V3DLONG cntBuf = 0;
	while (remainingBytes>0)
	{
		V3DLONG curReadBytes = (remainingBytes<nBytes2G) ? remainingBytes : nBytes2G;

        //the following is changed on 2014-09-21 consistent with the loadRaw2Stack() function to fix the big (>2G) float data reading bug seemingly in fread(). by PHC

//		V3DLONG curReadUnits = curReadBytes/unitSize;
//		nread = fread(img+cntBuf*nBytes2G, unitSize, curReadUnits, fid);
//		if (nread!=curReadUnits)

        nread = fread(img+cntBuf*nBytes2G, 1, curReadBytes, fid);
        if (nread!=curReadBytes)
        {
			printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
			if (keyread) {delete []keyread; keyread=0;}
			if (sz) {delete []sz; sz=0;}
			if (img) {delete []img; img=0;}
			berror = 1;
			return berror;
		}
		
		remainingBytes -= nBytes2G;
        printf("Finish reading %5.4f%%\r", (1-double(remainingBytes)/(double(totalBytes)))*100.0); fflush(stdout);
        cntBuf++;
	}
	
	// swap the data bytes if necessary 

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<channelUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}


/* The following is the core function for image stack writing */

int saveStack2Raw(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw_image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

    nwrite=fwrite(&dcode, 2, 1, fid);
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	//short int mysz[4];
    BIT32_UNIT mysz[4];
    for (i=0;i<4;i++) mysz[i] = (BIT32_UNIT) sz[i];
    nwrite = fwrite(mysz, 4, 4, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=4)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<4;i++)
	{
		totalUnit *= sz[i];
	}

	nwrite = fwrite(img, unitSize, totalUnit, fid);
	if (nwrite!=totalUnit)
	{
		printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
		berror = 1;
		return berror;
	}

	/* clean and return */

	fclose(fid);

	return berror;
}


int loadRaw5d2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype)
{
    /* This function reads 2-5D image stack from v3d raw5 data */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*5+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=mysz[4]=0;
	int tmpn=fread(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=5)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<5;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [5]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<5;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	//mexPrintf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*4+2+1+lenkey);
	//mexPrintf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
	if ((totalUnit*unitSize+4*5+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*5+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3], sz[4]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3], mysz[4]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<totalUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid); //bug fix on 060412

	return berror;
}

int loadRaw5d2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, int stack_id_to_load)
{
    /* This function reads 2-5D image stack from v3d raw5 data . */
	/* The input parameters img, sz, and datatype should be empty, especially the pointers "img" and "sz". */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n",
			   //mexPrintf("size of [V3DLONG]=[%d], [V3DLONG]=[%d] [int]=[%d], [short int]=[%d], [double]=[%d], [float]=[%d]\n",
			   sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));
    //printf("\n\n\n");

	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	/* Read header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	if (fileSize<lenkey+2+4*5+1) /* datatype has 2 bytes, and sz has 4*4 bytes and endian flag has 1 byte. */
	{
		printf("The size of your input file is too small and is not correct, -- it is too small to contain the legal header.\n");
		berror = 1;
		return berror;
	}

	char * keyread = new char [lenkey+1];
	if (!keyread)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}
	V3DLONG nread = fread(keyread, 1, lenkey, fid);
	if (nread!=lenkey)
	{
		printf("File unrecognized or corrupted file.\n");
		berror = 1;
		return berror;
	}
	keyread[lenkey] = '\0';

	V3DLONG i;
	if (strcmp(formatkey, keyread)) /* is non-zero then the two strings are different */
	{
		printf("Unrecognized file format.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	char endianCodeData;
	fread(&endianCodeData, 1, 1, fid);
	if (endianCodeData!='B' && endianCodeData!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Check your data endian.\n");
		berror = 1;
		if (keyread) {delete []keyread; keyread=0;}
		return berror;
	}

	int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	if (b_VERBOSE_PRINT)
    {
        printf("machine endian=[%c] data endian=[%c] b_swap=%d\n", endianCodeMachine, endianCodeData, b_swap);
    }


	short int dcode = 0;
	fread(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (b_swap)
		swap2bytes((void *)&dcode);

	switch (dcode)
	{
		case 1:
			datatype = 1; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", dcode);
			if (keyread) {delete []keyread; keyread=0;}
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=mysz[4]=0;
	int tmpn=fread(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=4)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	if (b_swap)
	{
		for (i=0;i<5;i++)
		{
			if (b_VERBOSE_PRINT)
				printf("mysz raw read unit[%ld]: [%d] ", i, mysz[i]);
			swap4bytes((void *)(mysz+i));
			if (b_VERBOSE_PRINT)
				printf("swap unit: [%d][%0x] \n", mysz[i], mysz[i]);
		}
	}

	if (stack_id_to_load<0 || stack_id_to_load>=mysz[4])
	{
                printf("The specified stack_id_to_load [=%d] is out of the valid of the image data [=%d] \n", stack_id_to_load, mysz[4]);
		return (berror=1);
	}

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [5]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1, stackUnit=1;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		stackUnit *= sz[i];
	}
	sz[4] = 1; //this must be true in case only one channel is read
	totalUnit = stackUnit*mysz[4];

	if ((totalUnit*unitSize+4*5+2+1+lenkey) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+4*5+2+1+lenkey);
		printf("The read sizes are: %ld %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3], sz[4]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3], mysz[4]);
		}
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [stackUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (stack_id_to_load>0) //other no need to call the function
		fseek(fid, stackUnit*stack_id_to_load*unitSize, SEEK_CUR);
	nread = fread(img, unitSize, stackUnit, fid);
	if (nread!=stackUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, stackUnit);
		if (keyread) {delete []keyread; keyread=0;}
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

	/* swap the data bytes if necessary */

	if (b_swap==1)
	{
		if (unitSize==2)
		{
			for (i=0;i<stackUnit; i++)
			{
				swap2bytes((void *)(img+i*unitSize));
			}
		}
		else if (unitSize==4)
		{
			for (i=0;i<stackUnit; i++)
			{
				swap4bytes((void *)(img+i*unitSize));
			}
		}
	}


	/* clean and return */

	if (keyread) {delete [] keyread; keyread = 0;}
	fclose(fid);

	return berror;
}

int saveStack2Raw5d(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype)
{
	/* This function save a data stack to raw file */
	if (b_VERBOSE_PRINT)
		printf("size of [V3DLONG]=[%ld], [V3DLONG]=[%ld] [int]=[%ld], [short int]=[%ld], [double]=[%ld], [float]=[%ld]\n", sizeof(V3DLONG), sizeof(V3DLONG), sizeof(int), sizeof(short int), sizeof(double), sizeof(float));

	int berror = 0;
	V3DLONG i;

	FILE * fid = fopen(filename, "wb");
	if (!fid)
	{
		printf("Fail to open file for writing.\n");
		berror = 1;
		return berror;
	}

	/* Write header */

	char formatkey[] = "raw5image_stack_by_hpeng";
	int lenkey = strlen(formatkey);

	V3DLONG nwrite = fwrite(formatkey, 1, lenkey, fid);
	if (nwrite!=lenkey)
	{
		printf("File write error.\n");
		berror = 1;
		return berror;
	}

	char endianCodeMachine = checkMachineEndian();
	if (endianCodeMachine!='B' && endianCodeMachine!='L')
	{
		printf("This program only supports big- or little- endian but not other format. Cannot save data on this machine.\n");
		berror = 1;
		return berror;
	}

	nwrite = fwrite(&endianCodeMachine, 1, 1, fid);
	if (nwrite!=1)
	{
		printf("Error happened in file writing.\n");
		berror = 1;
		return berror;
	}

	//int b_swap = (endianCodeMachine==endianCodeData)?0:1;
	//int b_swap = 0; //for this machine itself, should not swap data.

	short int dcode = (short int)datatype;
	if (dcode!=1 && dcode!=2 && dcode!=4)
	{
		printf("Unrecognized data type code [%d]. This code is not supported in this version.\n", dcode);
		berror = 1;
		return berror;
	}

	//if (b_swap) swap2bytes((void *)&dcode);
	nwrite=fwrite(&dcode, 2, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=1)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	BIT32_UNIT mysz[5];//090802
	for (i=0;i<5;i++) mysz[i] = (BIT32_UNIT) sz[i];
	nwrite = fwrite(mysz, 4, 5, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (nwrite!=5)
	{
		printf("Writing file error.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	for (i=0;i<5;i++)
	{
		totalUnit *= sz[i];
	}

	nwrite = fwrite(img, unitSize, totalUnit, fid);
	if (nwrite!=totalUnit)
	{
		printf("Something wrong in file writing. The program wrote [%ld data points] but the file says there should be [%ld data points].\n", nwrite, totalUnit);
		berror = 1;
		return berror;
	}

	/* clean and return */

	fclose(fid);

	return berror;
}


/* check the machine endianness */

char checkMachineEndian()
{
    char e='N'; //for unknown endianness

    V3DLONG int a=0x44332211;
    unsigned char * p = (unsigned char *)&a;
    if ((*p==0x11) && (*(p+1)==0x22) && (*(p+2)==0x33) && (*(p+3)==0x44))
        e = 'L';
    else if ((*p==0x44) && (*(p+1)==0x33) && (*(p+2)==0x22) && (*(p+3)==0x11))
        e = 'B';
    else if ((*p==0x22) && (*(p+1)==0x11) && (*(p+2)==0x44) && (*(p+3)==0x33))
        e = 'M';
    else
        e = 'N';

    //printf("[%c] \n", e);
    return e;
}


void swap2bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+1);
    *(tp+1) = a;
}

void swap4bytes(void *targetp)
{
    unsigned char * tp = (unsigned char *)targetp;
    unsigned char a = *tp;
    *tp = *(tp+3);
    *(tp+3) = a;
    a = *(tp+1);
    *(tp+1) = *(tp+2);
    *(tp+2) = a;
}

int loadRawSlice(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}

int loadRawSlice_2byte(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype, V3DLONG sliceno, bool b_thumbnail) //reserved for future use
{
return 0;
}


int loadMRC2Stack(char * filename, unsigned char * & img, V3DLONG * & sz, int & datatype) // MRC reading
{
	int berror = 0;

	FILE * fid = fopen(filename, "rb");
	if (!fid)
	{
		printf("Fail to open file for reading.\n");
		berror = 1;
		return berror;
	}

	fseek (fid, 0, SEEK_END);
	V3DLONG fileSize = ftell(fid);
	rewind(fid);

	//read header
	BIT32_UNIT mysz[4];
	mysz[0]=mysz[1]=mysz[2]=mysz[3]=0;
	int tmpn=fread(mysz, 4, 3, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */
	if (tmpn!=3)
	{
		printf("This program only reads [%d] units.\n", tmpn);
		berror=1;
		return berror;
	}
	mysz[3]=1; //now set #ch = 1

	V3DLONG dcode = 0;
	fread(&dcode, 4, 1, fid); /* because I have already checked the file size to be bigger than the header, no need to check the number of actual bytes read. */

	switch (dcode)
	{
		case 0: //signed 8bit
			datatype = 1;
			break;

		case 1: //signed 16bit
		case 6: //unsigned 16-bit
			datatype = 2;
			break;

		case 2: //float
			datatype = 4;
			break;

		default:
                        printf("Unrecognized data type code [%d]. The file type is incorrect or this code is not supported in this version.\n", (int)dcode);
			berror = 1;
			return berror;
	}

	V3DLONG unitSize = datatype; /* temporarily I use the same number, which indicates the number of bytes for each data point (pixel). This can be extended in the future. */

	fseek(fid,1024,SEEK_SET);

	if (sz) {delete []sz; sz=0;}
	sz = new V3DLONG [4]; /* reallocate the memory if the input parameter is non-null. Note that this requests the input is also an NULL point, the same to img. */
	if (!sz)
	{
		printf("Fail to allocate memory.\n");
		berror = 1;
		return berror;
	}

	V3DLONG totalUnit = 1;
	V3DLONG i, nread;
	for (i=0;i<4;i++)
	{
		sz[i] = (V3DLONG)mysz[i];
		totalUnit *= sz[i];
	}

	if ((totalUnit*unitSize+1024) != fileSize)
	{
		printf("The input file has a size [%ld bytes], different from what specified in the header [%ld bytes]. Exit.\n", fileSize, totalUnit*unitSize+1024);
		printf("The read sizes are: %ld %ld %ld %ld\n", sz[0], sz[1], sz[2], sz[3]);
		if (b_VERBOSE_PRINT)
		{
			printf("The read sizes are: %d %d %d %d\n", mysz[0], mysz[1], mysz[2], mysz[3]);
		}
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	if (img) {delete []img; img=0;}
	img = new unsigned char [totalUnit*unitSize];
	if (!img)
	{
		printf("Fail to allocate memory.\n");
		if (sz) {delete []sz; sz=0;}
		berror = 1;
		return berror;
	}

	nread = fread(img, unitSize, totalUnit, fid);
	if (nread!=totalUnit)
	{
		printf("Something wrong in file reading. The program reads [%ld data points] but the file says there should be [%ld data points].\n", nread, totalUnit);
		if (sz) {delete []sz; sz=0;}
		if (img) {delete []img; img=0;}
		berror = 1;
		return berror;
	}

//	/* swap the data bytes if necessary */
//
//	if (b_swap==1)
//	{
//		if (unitSize==2)
//		{
//			for (i=0;i<totalUnit; i++)
//			{
//				swap2bytes((void *)(img+i*unitSize));
//			}
//		}
//		else if (unitSize==4)
//		{
//			for (i=0;i<totalUnit; i++)
//			{
//				swap4bytes((void *)(img+i*unitSize));
//			}
//		}
//	}

	/* clean and return */

	fclose(fid);

	return berror;
}

int saveStack2MRC(const char * filename, const unsigned char * img, const V3DLONG * sz, int datatype) // MRC writing
{
	int berror=0;
	return berror;
}


//070214: add a simple interface to read and save all supported file formats

bool ensure_file_exists_and_size_not_too_big(char *filename, V3DLONG sz_thres)
{
#ifdef ENVIRONMENT32

    FILE * fid = fopen(filename, "rb");
    if (!fid)
    {
        printf("The file [%s] does not exist or cannot be read.\n", filename);
        return false;
    }

    fseek (fid, 0, SEEK_END);
    V3DLONG fileSize = ftell(fid);
    rewind(fid);
    fclose(fid);

    if(fileSize>sz_thres)
    {
        printf("The file [%s] has a too big size [= %ld bytes ] > [%ld bytes] which is the limit of the loadImage function. Do nothing. \n", filename, fileSize, sz_thres);
        return false;
    }

    return true;

#else

    return true;

#endif
}



//

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, int & datatype)
{
	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}

	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;
	bool b_5d=false;

    const char * curFileSuffix = getSuffix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);

//    if (curFileSuffix && (strcasecmp(curFileSuffix, "nrrd")==0)) //read nrrd stacks
//    {
//        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //tif file at most should be 900M bytes
//        {
//            printf("The tif file may not exist or may be too big to load.\n");
//            return false;
//        }
//        if (read_nrrd(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
//        {
//            printf("Error happens in NRRD file reading. Stop. \n");
//            return false;
//        }
//    }
    if (curFileSuffix && (strcasecmp(curFileSuffix, "tif")==0 || strcasecmp(curFileSuffix, "tiff")==0)) //read tiff stacks
	{
        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //tif file at most should be 900M bytes
		{
            printf("The tif file may not exist or may be too big to load [sz threshold=%ld bytes].\n", (V3DLONG)1024*1024*ZZBIG);
			return false;
		}
	}
#ifdef _ALLOW_WORKMODE_MENU_    
    else if (curFileSuffix/* && ImageLoaderBasic::hasPbdExtension(imgSrcFile) */) // read v3dpbd - pack-bit-difference encoding for sparse stacks
    {
//		v3d_msg("prepare for pbd file loading", 0);
//		Image4DSimple *tmpimg=new Image4DSimple;
		
//	    ImageLoaderBasic imageLoader;
//	    if (!imageLoader.loadImage(tmpimg, imgSrcFile)) {
//	        printf("Error happens in v3dpbd file reading. Stop. \n");
//	        return false;
//	    }
//	    // The following few lines are to avoid disturbing the existing code below
	    
//	    tmp_data1d = tmpimg->getRawData();
//	    tmp_datatype=tmpimg->getDatatype();
//	    tmp_sz=new V3DLONG[4];
//	    tmp_sz[0]=tmpimg->getXDim();
//	    tmp_sz[1]=tmpimg->getYDim();
//	    tmp_sz[2]=tmpimg->getZDim();
//	    tmp_sz[3]=tmpimg->getCDim();
	}
#endif
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "mrc")==0 ) //read MRC stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //MRC file at most should be 1.5G bytes
		{
			printf("The MRC file may not exist or may be too big to load.\n");
			return false;
		}
        
		if (loadMRC2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct MRC file. \n");
			return false;
		}
	}
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "raw5")==0 ) //read lsm stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //
		{
			printf("The lsm file may not exist or may be too big to load [sz threshold=%ld bytes].\n", (V3DLONG)1024*1024*ZZBIG);
			return false;
		}
		if (loadRaw5d2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			printf("Error happens in V3D .raw5 (5D) file reading. Stop. \n");
			return false;
		}
		b_5d = true;
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
                if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
                {
                        printf("The RAW file may not exist or may be too big to load.\n");
                        return false;
                }

		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}


	//copy output data

	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}

	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = (b_5d) ? tmp_sz[4] : 1; //090802

	data1d = tmp_data1d;
	
	/* clean all workspace variables */

	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	return true;
}

bool loadImage(char imgSrcFile[], unsigned char *& data1d, V3DLONG * &sz, int & datatype, int chan_id_to_load) //081204
{
	//printf("*** Warning: The overloaded function loadImage() with a specified channel only works for 4-byte RAW at this moment (as of 081204) ***. \n");
	if (chan_id_to_load<0)
	{
		printf("Warning: The specified chan_id_to_load is <0. \n");
		return false;
	}

	if (data1d)
	{
		printf("Warning: The pointer for 1d data storage is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []data1d; data1d=0;
	}
	if (sz)
	{
		printf("Warning: The pointer for size is not empty. This pointer will be freed first and the  reallocated. \n");
		delete []sz; sz=0;
	}

	unsigned char *tmp_data1d =0;
	V3DLONG * tmp_sz = 0; /* note that this variable must be initialized as NULL. */
	int tmp_datatype = 0;

    const char * curFileSuffix = getSuffix(imgSrcFile);
	if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);

 if ( curFileSuffix && strcasecmp(curFileSuffix, "lsm")==0 ) //read lsm stacks
	{
        if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //lsm file at most should be 900M bytes
		{
			printf("The lsm file may not exist or may be too big to load.\n");
			return false;
		}
	}
	else if ( curFileSuffix && strcasecmp(curFileSuffix, "mrc")==0 ) //read MRC stacks
	{
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //MRC file at most should be 1.5G bytes
		{
			printf("The MRC file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadMRC2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct MRC file. \n");
			return false;
		}
	}
	else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
			printf("The data is not with a TIF/LSM surfix, -- now this program assumes it is RAW format defined by Hanchuan Peng. \n");
		if (!ensure_file_exists_and_size_not_too_big(imgSrcFile, (V3DLONG)1024*1024*ZZBIG)) //RAW file at most should be 1.5G bytes
		{
			printf("The RAW file may not exist or may be too big to load.\n");
			return false;
		}

		if (loadRaw2Stack(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
		{
			if (b_VERBOSE_PRINT)
				printf("The data doesn't look like a correct 4-byte-size RAW file. Try 2-byte-raw. \n");
			if (loadRaw2Stack_2byte(imgSrcFile, tmp_data1d, tmp_sz, tmp_datatype, chan_id_to_load))
			{
				printf("Error happens in reading 2-byte-size RAW file. Stop. \n");
				return false;
			}
		}
	}

	//copy output data

	switch (tmp_datatype)
	{
		case 1:
			datatype = 1;
			break;

		case 2:
			datatype = 2;
			break;

		case 4:
			datatype = 4;
			break;

		default:
			printf("Something wrong with the program, -- should NOT display this message at all. Check your program. \n");
			if (data1d) {delete []data1d; data1d=0;}
				if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}
				if (sz) {delete []sz; sz=0;}
				return false;
	}

	sz = new V3DLONG [5];
	sz[0] = tmp_sz[0];
	sz[1] = tmp_sz[1];
	sz[2] = tmp_sz[2];
	sz[3] = tmp_sz[3]; //no longer merge the 3rd and 4th dimensions
	sz[4] = 1; //just set the 5th dim as 1 for consistency of the other loadImage() function

	data1d = tmp_data1d;

	/* clean all workspace variables */

	if (tmp_sz) {delete []tmp_sz; tmp_sz=0;}

	return true;
}


bool saveImage(const char filename[], const unsigned char * data1d, const V3DLONG * sz, const int datatype)
{
	if (!data1d || !filename || !sz)
	{
		printf("This image data is empty or the file name or the size pointer is invalid. Nothing done.\n");
		return false;
	}

	int dt;
    ImagePixelType curtype;
	switch (datatype)
	{
        case 1:  dt=1; curtype = V3D_UINT8; break;
        case 2:  dt=2; curtype = V3D_UINT16; break;
        case 4:  dt=4; curtype = V3D_FLOAT32; break;
		default:
			printf("The data type is unsupported. Nothing done.\n");
			return false;
			break;
	}

    const char * curFileSuffix = getSuffix((char *)filename);
    if (b_VERBOSE_PRINT)
		printf("The current input file has the surfix [%s]\n", curFileSuffix);
    
    if (curFileSuffix && strcasecmp(curFileSuffix, "raw5")==0) //write .raw5 data
	{
		if (saveStack2Raw5d(filename, data1d, sz, dt))
		{
			printf("Error happens in writing V3D .raw5 file [%s]. Stop. \n", filename);
			return false;
		}
	}
#ifdef _ALLOW_WORKMODE_MENU_
    else if (curFileSuffix &&  (strcasecmp(curFileSuffix, "v3dpbd")==0)) //  v3dpbd - pack-bit-difference encoding for sparse stacks
        // || strcasecmp(curFileSuffix, "mp4")==0) ) //to add mp4 later
    {
        v3d_msg("prepare for pbd file saving", 0);
        ImageLoaderBasic imageLoader;
        if (imageLoader.saveStack2RawPBD(filename, curtype, (unsigned char *)data1d, sz)) {
            printf("Error happens in v3dpbd file saving. Stop. \n");
            return false;
        }
    }
#endif
    else //then assume it is Hanchuan's RAW format
	{
		if (b_VERBOSE_PRINT)
            printf("The data is not with a known Vaa3D format, -- now this program assumes it is a Vaa3D RAW format. \n");
		if (saveStack2Raw(filename, data1d, sz, dt)!=0) //0 is no error //note that as I updated the saveStack2Raw to RAW-4-byte, the actual mask file cannot be read by the old wano program, i.e. the wano must be updated on Windows machine as well. 060921
		{
			printf("Error happens in writing RAW file stack [defined by Hanchuan Peng] [%s].\n", filename);
			return false;
		}
	}

    return true;
}


#endif //__STACKUTIL_CPP__


